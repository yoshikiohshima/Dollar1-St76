Point new x: 4.5 y: 5.5


When I do the follwing in a workspace in 76:

a _ Array new: 10

I get:

Smalltalk declare: ... a as: ...

with a curved arrow.  Presumably I should evaluate that.  But How do I enter the curved arrow?  Or is there a better way to do a workspace programming with variables?

user update: '0012sqrt-yo.st' message: 'add float primitive' _ ('Float sqrt')

user update: '0012sqrt-yo.st' message: 'add float primitive' _ Changes contents


| a.
a _ Stream default.
user filoutChanges: ('D1Stroke resample:with:') on: a.
user fileString: 'http://lively-web.org/users/ohshima/myfile.st' ← a contents.

resample: ps with: n | input d newPoints newIndex dd q currentP ii lastP i  "resample a sequence of points into a sequence with given length"
	[ii _ (self pathLength: ps) / (n - 1) asFloat.
	dd _ 0.
        input _ ps copy.
	newPoints _ Vector new: n.
        newPoints ◦ newIndex ← (ps ◦ 1).
        newIndex _ 1.
	i _ 2.
        while▹ [i ≤ input length] do▹
	   [
	      lastP _ input ◦ (i - 1).
              currentP _ (input ◦ i).
              d _ self dist: lastP and: currentP.
              [(dd + d) ≥ ii ⇒ [
                 q _ lastP + (((ii - dd) / d) * (currentP - lastP)).
                 newPoints ◦ newIndex _ q.
                 newIndex _ newIndex + 1.
  		 self add: q to: input beforeIndex: i.
                 dd _ 0]
               true ⇒ [
                 dd _ dd + d]].
              i _ i + 1].
        [(newPoints ◦ n) = nil ⇒ [newPoints ◦ n _ (input ◦ input length)]].
        ^ newPoints]


pathLength: ps | d lastP currentP "compute the total length of the sequence of points"
	    [d _ 0.0.
	    lastP _ ps ◦ 1.
	    for▹ i to: ps length do▹ [
	         [i > 1 ⇒ [
	    	    currentP _ ps ◦ i.
		    d _ d + (self dist: lastP and: currentP).
		    lastP _ currentP]]].
        ^ d]

dist: p1 and: p2 | dx dy "compute the euclid distance between two points"
      [dx _ p1 x - p2 x.
       dy _ p1 y - p2 y.
       ^ ((dx * dx) + (dy * dy)) asFloat sqrt]

add: elem to: col beforeIndex: ind | head tail mid "add elem into ps before specified index"
	[head _ col copy: 1 to: (ind - 1).
	tail _ col copy: ind to: col length.
	mid _ Vector new: 1.
	mid ◦ 1 _ elem.
	^ ((head concat: mid) concat: tail)]


centroid: ps | vx vy "compute the average of sequence of points"
	[vx _ (ps ◦ 1) x.
	vy _ (ps ◦ 1) y.
	for▹ i to: ps length do▹ [
	[i > 1 ⇒ [
		vx _ vx + (ps ◦ i) x.
		vy _ vy + (ps ◦ i) y]]].
		^ Point new x: (vx asFloat / ps length asFloat) y: (vy asFloat / ps length asFloat)]

rotate: ps by: rad | p newPoints r theta "rotate sequence of points"
	[newPoints _ Vector new: ps length.
	for▹ i to: ps length do▹ [
		p _ ps ◦ i.
		r _ self dist: p and: (Point new x: 0 y: 0).
		theta _ rad asFloat - (self theta: p).
		newPoints ◦ i _ ((r * theta cos)) @  (0 - (r * theta sin))].
	^ newPoints]

scale: ps to: size | bbExt "scale points"
	[bbExt := (self encompassingRectangle: ps) extent.
	newPoints _ Vector new: ps length.
	for▹ i to: ps length do▹ [
		p _ ps ◦ i.
		newPoints ◦ i _ (p x * size asFloat / bbExt x asFloat) @ (p y * size asFloat / bbExt y asFloat)].
	^ newPoints]

translate: ps to: newC | c p newPoints "translate points"
	[c _ (this centrold: ps) - newC.
	newPoints _ Vector new: ps length.
	for▹ i to: ps length do▹ [
		p _ ps ◦ i.
		newPoints ◦ i _ p - c].
	^ newPoints]

pathDistance: a from: b | ai bi d i "compute the average distance between corresponding points"
	[d _ 0.0.
	for▹ i to: a length do▹ [
		ai _ a ◦ i.
		bi _ b ◦ i.
		d _ d + (self dist: ai and: bi)].
	^ d / a length asFloat]

distance: stroke from: t atAngle: theta  | newPoints
	[newPoints _ stroke rotate: stroke points by: theta.
	^ self pathDistance: newPoints from: t points]

distanceAtBest: stroke from: t withThetaFrom: thetaA to: thetaB step: step | x1 x2 phi f1 f2 tA tB
	[phi _ 0.5 * (-1 + 5 sqrt).
	x1 _ (phi * thetaA) + ((1 - phi) * thetaB).
	f1 _ self distance: stroke from: t atAngle: x1.
	x2 _ (1 - phi) * thetaA + (phi * thetaB).
	f2 _ self distance: stroke from: t atAngle: x2.
	tA _ thetaA.
	tB _ thetaB.
	while▹ (tB - tA) abs > step do▹ [
		[f1 < f2 ⇒ [
			tB _ x2.
			x2 _ x1.
			f2 _ f1.
			x1 _ phi * tA + ((1 - phi) * tB).
			f1 _ self distance: stroke from: t atAngle: x1]
		true ⇒ [
			tA _ x1.
			x1 _ x2.
			f1 _ f2.
			x2 _ (1 - phi) * tA + (phi * tB).
			f2 _ self distance: stroke from: t atAngle: x2]]].
	^ f1 min: f2]

recognize: stroke against: temp2D in: size | b d bestT t ret i
	[b _ 10000000.0.
	bestT _ nil.
	for▹ i to: temp2D length do▹ [
		t _ temp2D ◦ i.
		d _ self distanceAtBest: stroke from: t withThetaFrom: theta negated to: 45 step: 2.
		[d < b ⇒ [
			b _ d.
			bestT _ t]]].
	ret _ Vector new: 2.
	ret ◦ 1 _ bestT.
	ret ◦ 2 _ 1 - (b / (0.5 * (2 * (size * size)) sqrt)).
	^ ret]

initTemplates
	[templates _ self defaultTemplates]


theta: aPoint | x y theta tan
	[x _ aPoint x.
	 y _ aPoint y.
	 [x = 0 ⇒ [
		[y ≥ 0 ⇒ [^ 1.5707963267948966]
		 true ⇒ [^ 4.71238898038469]]]].
	 tan _ y asFloat / x asFloat.
	 theta _ self arctan: tan.
	 [x ≥ 0 ⇒ [
		[y ≥ 0 ⇒ [^ theta]
		[true ⇒ [^ 6.283185307179586 + theta]]
	 true ⇒ [3.141592653589793 + theta]]]

preProcess | radians
	[points _ self resample: points with: 64.
	points _ self translate: points to: 0@0.
	radians _ self indicativeAngle: points.
	points _ self rotate: points by: radians.
	points _ self scale: points to: 250]


distance: stroke from: t atAngle: theta | newPoints
	[newPoints _ stroke rotate: stroke points by: theta.
	^ self pathDistance: newPoints from: t points]

makePointsFromData: cs | ps i
	[ps _ Vector new: cs length / 2.
	i _ 1.
	while i  ps length do
		[ps  i _ Point new x: cs  (i * 2 - 1) y: cs  (i * 2).
		i _ i + 1].
	ps]

